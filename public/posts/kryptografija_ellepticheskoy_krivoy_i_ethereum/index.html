<!doctype html><html lang=ru-RU><head><meta charset=utf-8><link rel=preconnect href=https://fonts.gstatic.com><title>Криптография эллиптической кривой (ECC) и Ethereum | Ilya Krukowski</title>
<meta name=viewport content="width=device-width"><meta name=description content='Мы поговорим о том, что такое криптография эллиптической кривой (elliptic-curve cryptography, ECC) и как она используется в Ethereum.'><meta name=keywords content="Ilya Krukowski,Илья Круковский,bodrovis,статьи о web,программирование,дизайн,регулярные выражения,web-дизайн,ruby,rails,javascript,jquery,css,html,regexp,плагины,radiant wind,plugins,gems,libraries,tutor,personal teacher,it"><meta name=author content="bodrovis"><meta name=robots content="all"><link rel=apple-touch-icon href=/apple-touch-icon.png><link rel=icon href=/favicon.ico type=image/x-icon><link rel="shortcut icon" href=/favicon.ico type=image/x-icon><link href="https://fonts.googleapis.com/css2?family=PT+Sans+Caption:wght@700&family=PT+Sans:wght@400;700&display=swap" rel=stylesheet><link rel=stylesheet href=/stylesheets/single_post.min.926317024216b8a9c7bc2f46a80dfa91d60a46803b854cc61fb86a57bb720bb3.css integrity="sha256-kmMXAkIWuKnHvC9GqA36kdYKRoA7hUzGH7hqV7tyC7M=" crossorigin=anonymous><meta property="og:image" content><meta property="og:type" content="blog"><meta property="og:title" content="Криптография эллиптической кривой (ECC) и Ethereum |  by Ilya Krukowski"><meta property="og:description" content="Мы поговорим о том, что такое криптография эллиптической кривой (elliptic-curve cryptography, ECC) и как она используется в Ethereum."><meta property="og:url" content="https://bodrovis.tech/posts/kryptografija_ellepticheskoy_krivoy_i_ethereum/"><meta property="og:site_name" content="Ilya Krukowski"></head><body><header lang=en-US><div id=main-top-block class=light_gradient><nav><a href=/ class="icon icon-home" title=Homepage></a><a class="icon icon-book" title=Blog href=/blog></a><a class="icon icon-tags" title=Tags href=/tags></a><a class="icon icon-search with-spacer" title=Search href=/search></a><a class="icon icon-github" title=GitHub href=https://github.com/bodrovis target=_blank></a><a class="icon icon-youtube" title=YouTube href=https://www.youtube.com/@IlyaBodrovKrukowski target=_blank></a><a class="icon icon-telegram" title=Telegram href=https://t.me/dev_in_ruby_colors target=_blank></a><a class="icon icon-linkedin" title=LinkedIn href=https://linkedin.com/in/bodrovis target=_blank></a><a class="icon icon-envelop" title=E-mail id=icon-mail href=mailto:bodrovis@protonmail.com></a></nav></div><div id=logo><img src=/images/icon150trans.webp width=150 height=150 alt="Ilya Krukowski logo" class=img-logo><p><span class=capital>I</span>lya <span class=capital>K</span>rukowski
<span class=subtitle>https://bodrovis.tech</span></p></a></header><main id=content data-pagefind-body><h1>Криптография эллиптической кривой (ECC) и Ethereum</h1><article class=full-entry><time class="timestamp subtext" datetime="2024-03-06 00:00:00 +0000 UTC">March 6, 2024
</time><a class=badge href=/tags/%D0%BA%D1%80%D0%B8%D0%BF%D1%82%D0%BE%D0%B3%D1%80%D0%B0%D1%84%D0%B8%D1%8F>#криптография</a>
<a class=badge href=/tags/ethereum>#ethereum</a><section id=post-body><aside><nav id=TableOfContents></nav></aside><p>Сегодня мы с вами поговорим о <strong>криптографии эллиптической кривой (elliptic-curve cryptography, ECC)</strong> и конкретно о том, как она используется в <strong>Ethereum</strong>.</p><p>Это запись по следам видеоурока, который можно найти на YouTube:</p><iframe width=560 height=315 src="https://www.youtube.com/embed/q51qT9MRbLs?si=GQE_-k4nnAgpVmBh" title="YouTube video player" frameborder=0 allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; web-share" allowfullscreen></iframe><p><em>Эта запись также доступна <a href=https://t.me/dev_in_ruby_colors/788>в канале Telegram &ldquo;DEV: Рубиновые тона&rdquo;</a>, а обсудить же эту тему можно <a href=https://t.me/+MxYT6-01eeA1NTYy>в нашем чате Telegram</a>.</em></p><h2>Зачем ECC нужна в Ethereum?</h2><p>Первый вопрос, который может возникнуть у пытливого читателя: зачем вообще всё это надо? Что ж, это весьма логичный вопрос! Дело в том, что (применительно к Ethereum) любая транзакция должна быть <strong>подписана</strong> пользователем. Мы должны подтвердить, что, условно говоря, вот этот денежный перевод со своего кошелька делаю действительно я, а не какой-то неизвестный товарищ. Если говорить из общих соображений, то подпись транзакции подразумевает высчитывание её хэша и последующее шифрование получившегося хэша с помощью закрытого ключа (private key) пользователя. Закрытый ключ, как подсказывает название, известен лишь самому юзеру, и в общем целом это называется &ldquo;ассиметричное шифрование&rdquo;, то есть шифруем одним, дешифруем другим.</p><p>Принимающая сторона берёт транзакцию и тоже высчитывает её хэш, после чего расшифровывает присланную подпись. Расшифровка происходит с помощью открытого ключа пользователя, который может быть известен кому угодно. Если хэши совпали, то всё хорошо, если нет — где-то есть проблема. Кроме того, мы знаем, что в том же Solidity есть функция <code>ecrecover</code>, которая может сказать, кто именно подписал сообщение.</p><p>Другой пример — это использование ассиметричного шифрования для так называемого handshake, когда две стороны вырабатывают общий ключ. Этот ключ используется во время обмена данными (например, по https). Про это мы говорили в лекции по RSA.</p><p>Из всего этого мы делаем простой вывод: <strong>наличие открытого и закрытого ключа принципиально важно для криптовалют</strong> и не только. И вот тут-то мы задаёмся другим вопросом: а откуда эти ключи взять и как сделать их надёжными? В частности, нам нужно, чтобы на основе известного закрытого ключа можно было легко посчитать открытый, но ни в коем случае не наоборот, иначе закрытые ключи пользователей будут скомпрометированы! Собственно говоря, над этой проблемой, в том числе, и работают криптографы. Один вариант — использовать старый добрый RSA, где ключами выступают обычные числа (только очень большие). Но мир не стоит на месте, и поэтому был придуман другой подход, который и основывается на <strong>эллиптической кривой</strong>. Он быстрее, надёжнее и менее ресурсозатратен, что особенно важно для маломощных устройств.</p><h2>Какие ещё кривые?..</h2><p>Таким образом, мы поняли, зачем вообще этот ECC нужен: мы можем использовать некие эллиптические кривые, чтобы создавать надёжные ключи, которые затем используются для шифрования и дешифрования. Но что же это за кривые такие? В общем случае у таких кривых довольно длинное уравнение, но в крипте мы работаем с кривыми Вейерштрасса, которые попроще. Описываются они следующим уравнением: <code>y ** 2 = x ** 3 + a * x + b</code>.</p><p><code>**</code> — это операция возведения в степень. <code>a</code> и <code>b</code> — это параметры кривой, которые подбираются криптографами и могут варьироваться в зависимости от стандарта. Важно то, что эти параметры известны абсолютно всем, они не являются секретными и описаны прямо в стандарте. К примеру, для Bitcoin и Ethereum используется кривая под названием <a href=https://en.bitcoin.it/wiki/Secp256k1>secp256k1</a>, параметры которой равны <code>0</code> и <code>7</code> соответственно, то есть уравнение же превращается в <code>y ** 2 = x ** 3 + 7</code>.</p><p>Как выглядят эллиптические кривые и как меняются в зависимости от параметров, можно <a href=https://www.desmos.com/calculator/ialhd71we3>посмотреть вот на этой визуализации</a>. В частности, можно видеть, что эта кривая симметрична относительно оси Х, что довольно важно (есть у неё и ряд других свойств, о которых позже).</p><p>Также следует отметить, что эти кривые строятся на конечном поле <code>Fp</code> (оно называется поле Галуа), где <code>p</code> — это простое число. Если говорить простым языком, то кривая не бесконечна, а лежит в квадрате размером <code>p x p</code>. В стандартах, используемых в реальных системах, число <code>p</code> очень большое. К примеру, для кривой <code>secp256k1</code> значение <code>p</code> равно <code>2 ** 190 - 1</code>, и это совершенно гигантское число. Это нужно для того, чтобы мы могли сгенерировать очень много потенциальных ключевых пар. Поэтому фактически мы можем сказать, что наше уравнение трансформируется в <code>y ** 2 = x ** 3 + 7 (mod p)</code>, где <code>mod</code> — остаток от деления.</p><p>Ещё один важный момент заключается в том, что в ECC мы работаем только с целыми числами, поэтому на нашей кривой нас интересуют только точки, чьи координаты <code>x</code> и <code>y</code> целые. Кстати, проверить, принадлежит ли точка кривой можно очень легко: для этого нужно решить уравнение <code>x ** 3 + 7 - y ** 2 = 0</code> (опять таки с <code>mod p</code>). Если равенство нулю есть, то точка лежит на кривой.</p><h2>Получение открытого ключа на кривой</h2><p>На поле Галуа, где лежит кривая, можно выполнять математические операции над точками: так, две произвольные точки можно складывать и результатом будет другая точка на кривой. Это, на самом деле, принципиально важный момент, связанный с получением открытого ключа. Как именно сложение происходит визуально, можно увидеть <a href=https://www.desmos.com/calculator/ialhd71we3>вот на этом сервисе</a>. В частности, на нём вы увидите две точки (оранжевую и синюю), через которые проведена прямая. Третья точка чёрного цвета, где эта прямая пересекает кривую, и есть результат сложения. Только заметьте, что эта точка инвертирована относительно оси X и финальный результат оказывается по другую сторону.</p><p>Какие используются формулы для сложения точек, вы можете посмотреть в умных книжках, но нас это не сильно интересует. Важно то, что этот подход мы можем использовать для получения открытого ключа.</p><p>Алгоритм выглядит следующим образом:</p><ul><li><p>На кривой задаётся изначальная точка <code>G</code>, которая называется <strong>генераторной</strong>. Про неё ещё потом скажу пару слов, но важно то, что для конкретного алгоритма эта точка известна абсолютно всем: к примеру, для <code>secp256k1</code> её координаты равны <code>02 79BE667E F9DCBBAC 55A06295 CE870B07 029BFCDB 2DCE28D9 59F2815B 16F81798</code>. Вы можете спросить, почему тут только одна координата, хотя мы работаем с осями X и Y, но про это будет позднее. Пока просто поверьте, что это координаты точки по двум осям, только в сжатом виде.</p></li><li><p>Мы можем сложить эту точку саму с собой: как ни странно, это тоже допустимо. В результате мы получим новую точку <code>A</code>, которую можно записать простым выражением <code>A = G + G</code>. Ну, а коль скоро у нас есть сложение, то и умножение мы тоже можем сделать, то есть <code>A = 2 * G</code>. Кстати, на мой скромный взгляд, во многих руководствах вот этому моменту вообще не уделяется внимания. Часто пишут в духе &ldquo;возьмём две точки, проведём прямую, получим третью&rdquo;. Но, пардон, изначально-то генераторная точка одна — откуда тогда взялась ещё и вторая?</p></li><li><p>Затем мы можем посчитать точку <code>B</code> путём сложения <code>G</code> с уже посчитанной точкой <code>A</code>. <code>B = G + A = G + 2 * G = 3 * G</code>.</p></li><li><p>Guess what: мы можем продолжать эту операцию сколько угодно раз. Проделайте эти вычисления самостоятельно <a href=https://andrea.corbellini.name/ecc/interactive/modk-add.html>вот на этом онлайн-калькуляторе</a>, введя параметры <code>a = 0</code>, <code>b = 7</code>, <code>p = 17</code> (совсем крошечное поле для простоты, но помните, что в реальной жизни оно гигантское). Затем просто задайте координаты для обеих точек в <code>(15, 13)</code> (в калькуляторе эти точки названы <code>P</code> и <code>Q</code>, но суть не меняется), и вы увидите, что результатом сложения выступит точка <code>(2, 10)</code>. Потом можете повторить сложение <code>(15, 13)</code> и <code>(2, 10)</code>, и так далее.</p></li></ul><p>Вспоминается старый анекдот: куда мы попадём, если будем долго бурить землю на экваторе? Видимо, в сумасшедший дом. Тут можно задать тот же вопрос: где мы окажемся, если будем повторять это умножение и, самое главное, нафига вообще это нужно?</p><ul><li><p>Ответ на первый вопрос очень простой: в конце концов мы окажемся в какой-то точке на кривой, обозначенной <code>P</code>, у которой также есть координаты <code>x</code> и <code>y</code>, причём выражены они тоже целыми числами.</p></li><li><p>Ответ на второй вопрос тоже не сильно сложный: координаты финальной точки <code>P</code> будут выступать <strong>открытым ключом</strong>. Да, это два числа, а ключ вроде как один, но мы можем просто слепить их воедино. К примеру, для Ethereum каждая координата имеет размерность 256 бит, значит две координаты дают размерность 512 бит — это и есть размер открытого ключа в несжатом виде.</p></li></ul><p>Ладно, а где тогда закрытый ключ? А закрытый ключ, дорогие друзья, — это то число, на которое мы умножаем <code>G</code>. Скажем, в примере выше у нас получилось, что <code>B = 3 * G</code>, значит закрытый ключ <code>k</code> равен <code>3</code>. Естественно, это очень простой пример, а в реальности же закрытые ключи лежат в диапазоне от <code>1</code> до <code>2 ** 256 - 1</code>, то есть опять же числа нереально здоровые. Закрытый ключ можно получить хотя бы из мнемонической фразы, которая пропущена через тот же <code>keccak256</code>. Так как этот алгоритм хэширования гарантирует, что выходное шестнадцатиричное число будет меньше, чем <code>2 ** 256</code>, то нас это прекрасным образом устраивает (хотя схемы могут быть сложнее).</p><h3>Закрытый и открытый ключи</h3><p>А главная замута здесь вот в чём. Посчитать открытый ключ по формуле <code>P = k * G</code> — это достаточно простая и быстрая операция, которая выполняется за время <code>log2(k)</code>. Но вот сделать обратную операцию и узнать закрытый ключ по известному открытому, то есть сделать что-то вроде <code>k = P / G</code> — это задача на данный момент практически невыполнимая, если, конечно, используются достаточно большие числа. Эта проблема называется <strong>Elliptic Curve Discrete Logarithm Problem (ECDLP)</strong>; эффективного решения она не имеет, что гарантирует надёжность алгоритма. Опять же, говоря простым языком, даже если мы знаем начальную и финальную точку на кривой, мы в душе не знаем, сколько потребовалось &ldquo;прыжков&rdquo; для того, чтобы в этой финальной точке оказаться.</p><h2>Подгруппы точек на кривой</h2><p>Все точки на эллиптической кривой можно разделить на так называемые <strong>циклические подгруппы</strong>. В разных вариантах кривой (эти варианты зависят от изначальных параметров) может быть разное количество подгрупп, которое выражается числом <code>h</code>. Это число называется <strong>ко-фактор (cofactor)</strong>. Например, для <code>secp256k1</code> кофактор равен <code>1</code>, то есть все точки лежат в одной подгруппе.</p><p>Общее количество вообще всех точек во всех подгруппах называется <strong>порядок кривой</strong> и выражается числом <code>n</code>. Для уже известной нам кривой <code>secp256k1</code> значение <code>n</code> равно (внимание) <code>FFFFFFFF FFFFFFFF FFFFFFFF FFFFFFFE BAAEDCE6 AF48A03B BFD25E8C D0364141</code> — это в виде hexadecimal. То есть вот столько там есть возможных точек и, соответственно, ключей.</p><p>Почему важны все эти кофакторы? Потому что генераторная точка <code>G</code> может сгенерировать любую другую точку в рамках своей подгруппы, если сделать достаточно большое количество &ldquo;прыжков&rdquo; (то есть умножений). Частным случаем является умножение на <code>0</code> — там получается бесконечность и такая точка нам, конечно, не подходит. Таким образом, для кривой <code>secp256k1</code> мы можем попасть в каждую другую точку из генераторной. Собственно, <code>G</code> выбрана умными людьми специально, чтобы из неё можно было попасть в наибольшее количество других точек. Именно поэтому следует использовать уже готовые и протестированные кривые, а не придумывать собственную.</p><h2>Сжатие координат</h2><p>И последний момент, связанный со сжатием координат <code>(x, y)</code> для наших открытых ключей. Дело в том, что у кривой Вейерштрасса есть другое любопытное свойство: на каждую координату там приходится максимум две точки, что проиллюстрировано <a href="https://60896510-files.gitbook.io/~/files/v0/b/gitbook-x-prod.appspot.com/o/spaces%2F-LhlOQMrG9bRiqWpegM0%2Fuploads%2Fgit-blob-88e7096ea7710831737bc083a128836c03c6da9b%2Felliptic-curve-over-f17-points-per-y-coordinate.png?alt=media">на этом рисунке</a>.</p><p>Больше того, выходит, что если есть две точки с одинаковыми координатами по оси X, то по для одной точки по Y будет чётная координата, а для другой — нечётная. Неплохо, да? Это значит, что для каждой точки мы можем оставить только её координату по X, а Y выразить как чёт-нечёт, то есть занять фактически лишь один бит. Таким образом, мы можем сжать 512-битную пару <code>(x, y)</code> до 257 бит!</p><p>&ldquo;Расжать&rdquo; координату по Y можно по формулам <code>y1 = mod_sqrt(x ** 3 + ax + b, p)</code> и <code>y2 = p - mod_sqrt(x ** 3 + ax + b, p)</code>, где <code>mod_sqrt</code> — это квадратный корень с операцией модуля, который считается по <a href=https://en.wikipedia.org/wiki/Tonelli%E2%80%93Shanks_algorithm>алгоритму Тонелли-Шенкса</a>, но обычно это не столь важно для разработчиков в Ethereum. Получив две координаты по Y мы просто выбираем либо чётную, либо нечётную. Хитро, что и говорить.</p><h2>Заключение</h2><p>Подведём итог. Для того, чтобы посчитать открытый ключ с помощью ECC, нам требуется:</p><ul><li><p>Выбрать кривую, например, <code>secp256k1</code>. Выбранная кривая влияет на параметры <code>a</code> и <code>b</code>, у неё есть известная генераторная точка, а также известный порядок и кофактор.</p></li><li><p>Каким-то образом создать закрытый ключ <code>k</code> (выбрать случайное число, использовать мнемоническую фразу или как-то ещё).</p></li><li><p>Умножить <code>G</code> на <code>k</code> и получить финальные координаты точки <code>P</code>, открытого ключа.</p></li></ul><p>В Ethereum, кстати, потом происходит интересная штука, так как полученный открытый ключ хэшируется, а последние 20 байт (160 бит) этого хэша становятся <strong>адресом аккаунта</strong>, которому этот публичный ключ соответствует. Так как хэш представляет собой числа hexadecimal, то и адрес тоже является шестнадцатиричным числом. А это значит, что мы можем превратить его в обычное число <code>uint256</code>, если вдруг такая необходимость есть: <code>uint256(uint160(some_address))</code>. В других системах может быть такое, что сам публичный ключ и выступает адресом.</p></section></article></main><footer class=light_gradient lang=en-US><p>&copy; Ilya Krukowski</p></footer><script src=/js/post.min.c6a3ca85a318ecf83b8e11535463ad9865ecb2fa1528b59e028c79a6834fc21b.js integrity="sha256-xqPKhaMY7Pg7jhFTVGOtmGXssvoVKLWeAox5poNPwhs=" defer></script></body></html>