<!DOCTYPE html>

<html lang="ru-RU">
  <head><script src="/livereload.js?mindelay=10&amp;v=2&amp;port=1313&amp;path=livereload" data-no-instant defer></script>
    <meta charset="utf-8">
    <link rel="preconnect" href="https://fonts.gstatic.com">
    <title>Big-endian и little-endian: порядок следования байтов и причём тут Гулливер | Ilya Krukowski</title>
    <meta name="viewport" content="width=device-width">
    <meta name="description" content='Мы узнаем, в чём заключается смысл понятий big-endian и little-endian, как это связано с порядком следования байтов и причём тут Гулливер.'>
    <meta name="keywords" content="Ilya Krukowski, Илья Круковский, bodrovis, статьи о web, программирование, дизайн, регулярные выражения, web-дизайн, ruby, rails, javascript, jquery, css, html, regexp, плагины, radiant wind, plugins, gems, libraries, tutor, personal teacher, it">
    <meta name="author" content="bodrovis">
    <meta name="robots" content="all">
    <link rel="apple-touch-icon" href="/apple-touch-icon.png">
    <link rel="icon" href="/favicon.ico" type="image/x-icon">
    <link rel="shortcut icon" href="/favicon.ico" type="image/x-icon">

    
<link href="https://fonts.googleapis.com/css2?family=PT+Sans+Caption:wght@400;700&family=PT+Sans:wght@400;700&display=swap" rel="stylesheet">



  

  
    
      <link rel="stylesheet" href="/stylesheets/single_post.css">
    
  



    




<meta property="og:image" content="http://localhost:1313//meta/big_endian_i_little_endian_poryadok_sledovaniya_baytov.webp">

<meta property="og:type" content="blog">
<meta property="og:title" content="Big-endian и little-endian: порядок следования байтов и причём тут Гулливер |  by Ilya Krukowski">
<meta property="og:description" content="Мы узнаем, в чём заключается смысл понятий big-endian и little-endian, как это связано с порядком следования байтов и причём тут Гулливер.">
<meta property="og:url" content="http://localhost:1313/posts/big_endian_i_little_endian_poryadok_sledovaniya_baytov/">
<meta property="og:site_name" content="Ilya Krukowski">

  </head>
  <body>
    
<header lang="en-US">
  <div id="main-top-block" class="light_gradient">
    <nav>
      <a href="/" class="icon icon-home" title="Homepage"></a>
      <a class="icon icon-book" title="Blog" href="/blog"></a>
      <a class="icon icon-tags" title="Tags" href="/tags"></a>
      <a class="icon icon-search with-spacer" title="Search" href="/search"></a>
      <a class="icon icon-github" title="GitHub" href="https://github.com/bodrovis" target="_blank"></a>
      <a class="icon icon-youtube" title="YouTube" href="https://www.youtube.com/@IlyaBodrovKrukowski" target="_blank"></a>
      <a class="icon icon-telegram" title="Telegram" href="https://t.me/dev_in_ruby_colors" target="_blank"></a>
      <a class="icon icon-linkedin" title="LinkedIn" href="https://linkedin.com/in/bodrovis" target="_blank"></a>
      <a class="icon icon-envelop" title="E-mail" id="icon-mail" href="mailto:bodrovis@protonmail.com"></a>
    </nav>
  </div>

  <div id="logo">
    
      <img src="/images/icon150trans.webp" width="150" height="150" alt="Ilya Krukowski logo" class="img-logo">
    
    
    <p>
      <a href="/blog">
        <span class="capital">I</span>lya <span class="capital">K</span>rukowski

        <span class="subtitle">https://bodrovis.tech</span>
      </a>
    </p>
  </a>
</header>

<main id="content" data-pagefind-body>
  <h1>Big-endian и little-endian: порядок следования байтов и причём тут Гулливер</h1>

  <article class="full-entry">
    <time class="timestamp subtext" datetime="2024-03-11 12:00:00 &#43;0000 UTC">
      March 11, 2024
    </time>

    
    
    <a class="badge" href="/tags/cs">#cs</a>
    
    

    <section id="post-body">
      
<aside id="toc-wrapper">
  <h4>Index</h4>
  <nav id="TableOfContents">
  <ul>
    <li><a href="#дом-который-построил-свифт">Дом, который построил Свифт</a></li>
    <li><a href="#порядок-следования-байтов">Порядок следования байтов</a></li>
    <li><a href="#есть-ли-принципиальная-разница">Есть ли принципиальная разница?</a></li>
  </ul>
</nav>
</aside>


      <p>В этой статье мы поговорим о понятиях <strong>big-endian и little-endian</strong> в computer science.</p>
<p><em>Эта запись также доступна <a href="https://t.me/dev_in_ruby_colors/963">в канале Telegram &ldquo;DEV: Рубиновые тона&rdquo;</a>, а обсудить же эту тему можно <a href="https://t.me/+MxYT6-01eeA1NTYy">в нашем чате Telegram</a>.</em></p>
<h2 id="дом-который-построил-свифт">Дом, который построил Свифт</h2>
<p>Частенько в руководствах и документации можно встретить термины big-endian и little-endian — да хотя бы в <a href="http://localhost:1313/posts/chto_takoe_unicode_utf8_i_ascii/">статье про кодировки UTF8 и ASCII</a>. Но что эти понятия вообще значат? На самом деле, всё довольно просто: это буквально война тупоконечников и остроконечников (я серьёзно).</p>
<p>Когда-то давно Джонатан Свифт написал роман &ldquo;Путешествия Гулливера&rdquo; — помните такой? Там была история, что, дескать, изначально варёные яйца лилипуты разбивали с тупого конца, но потом один из императоров умудрился себе порезать руку за завтраком, очищая яичко, после чего был издан указ: разбивать яйца только с острого конца, иначе будут применяться санкции.</p>
<p>Это привело к кровавым бунтам, тысячи человек пошли на казнь, так как, следуя заветам предков, всё равно разбивали яйца с тупого конца. По этой теме писались книги (хотя тупоконечную литературу запрещали), устраивались диспуты, и так далее, хотя в главном трактате некоего пророка было написано просто &ldquo;разбивайте так, как вам больше нравится&rdquo;. Скажем прямо, в реальной жизни подобный идиотизм тоже встречается частенько. Это, конечно, едкая сатира, но она напрямую связана с нашим вопросом.</p>
<p>В оригинале &ldquo;тупоконечники&rdquo; — это &ldquo;big endians&rdquo;, а их противники — &ldquo;little endians&rdquo;. Отсюда и пошли эти термины; впервые в далёком 80-м году их употребил Дэнни Коэн, один из участников проекта ARPANet. Это была во многом шутка, но в итоге словечки прижились.</p>
<h2 id="порядок-следования-байтов">Порядок следования байтов</h2>
<p>Предположим, у нас есть шестнадцатеричное число <code>0x12345678</code>, и оно размещается в памяти, начиная с адреса <code>0x100</code> (про организацию память можно <a href="https://youtube.com/live/1B6lBJUQ5q8?feature=share">глянуть стрим</a>). Каждая двойка шестнадцатеричных чисел (<code>12</code>, <code>34</code> и так далее) занимает по 8 бит, потому что каждое число hex занимает 4 бит: <code>0x0 = 0b0000</code>, <code>0xf = 0b1111</code>. Следовательно, для хранения этого числа потребуется 4 байта или 32 бита (это называется &ldquo;слово&rdquo;, &ldquo;word&rdquo;). Если принять, что каждый адрес в памяти указывает на 8 бит информации, то наше число займёт адреса с <code>0x100 </code>по <code>0x103</code>. Но вопрос в том, как эти пары там разместить: справа налево или слева направо?</p>
<p>Можно сделать так:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">100  101  102  103
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">12   34   56   78
</span></span></code></pre></div><p>Но можно сделать и так:</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-text" data-lang="text"><span class="line"><span class="cl">100  101  102  103
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">78   56   34   12
</span></span></code></pre></div><p>То есть сначала может идти &ldquo;самая значимая&rdquo; пара (это <code>0x12</code>), а может, наоборот, наименее значимая (<code>0x78</code>). Казалось бы, выбор очевиден, но можно вспомнить хотя бы о том, что некоторые народы читают справа налево, а кто-то вообще пишет столбиком. Так что, на самом деле, всё не так однозначно™.</p>
<p>Поэтому подход, когда наиболее значимый байт идёт на первой позиции, называется &ldquo;big endian&rdquo; или BE (большинству из нас это куда привычнее), а &ldquo;little endian&rdquo; или LE — это когда сначала идёт наименее значимый байт. В разных машинах может задействоваться один из двух подходов, к примеру, многие устройства (но не все) от Oracle используют режим big endian. Впрочем, есть чипы вида bi-endian, которые умеют работать в обоих режимах.</p>
<p>Кроме того, многое зависит от самой операционной системы. Так, Android и iOS используют именно little-endian, с Windows в целом аналогичная история. В сетевых же протоколах, напротив, используется вариант big endian (принятую по сети информацию может потребоваться переставить обратно в вариант little endian, в зависимости от машины).</p>
<h2 id="есть-ли-принципиальная-разница">Есть ли принципиальная разница?</h2>
<p>На самом деле, с технической точки зрения нет особенной разницы, какой вариант представления использовать, равно как и нет разницы, с какой стороны разбивать яйцо. Для обычных программистов знать, какой режим использует ОС, особенно не нужно, потому что это должны учитывать компиляторы.</p>
<p>Однако этот термин может встречаться в других местах — например, в документации Solidity и Ethereum, где рассказывается о хранении данных в слотах (к примеру, uint хранится в виде big endian, равно как и селектор функции в calldata).</p>
<p>Интересно, что сказал бы по этому поводу Свифт&hellip;</p>

    </section>
  </article>
</main>

<footer class="light_gradient" lang="en-US">
  <p>
    &copy; Ilya Krukowski
  </p>
</footer>


    <script src="/js/post.min.c6a3ca85a318ecf83b8e11535463ad9865ecb2fa1528b59e028c79a6834fc21b.js" integrity="sha256-xqPKhaMY7Pg7jhFTVGOtmGXssvoVKLWeAox5poNPwhs=" defer></script>

  </body>
</html>